FilesystemsOlder Linux distributions default to using the ext3 filesystem, which is reliable but not the fastest around. The newer ext4 is faster but still a bit immature; make sure you load test heavily before deploying it. A good middle ground is XFS, which is very stable at this point while also being quite fast. All these filesystems benefit from using the "noatime" mounting parameter. That eliminates updating information about when files were last accessed, something that's normally not important for databases.Read-aheadPostgreSQL relies on the operating system to do some amount of read-ahead, which is essential to good read performance on sequential scans of large tables. Linux has an excellent read-ahead implementation, but it's set to a low number of blocks (256) to grab by default. 4096 blocks is a good starting point to use for that setting instead, and read-ahead is set on block devices like this:/sbin/blockdev --setra 4096 /dev/sdaReliable & Fast WritesGetting the best performance from PostgreSQL can require selecting the right hardware for that job. And choosing the wrong hardware or setting it up incorrectly can put your data at risk. You can find articles on hardware selection and operating system options needed for both good performance and reliable database writes at http://pgmag.org/0017For example, if you have a system with a battery-backed write controller, that greatly improves write performance. But XFS and ext4 filesystems will need the "nobarrier" mount option to work well with it.Write cachingOn the write side, PostgreSQL expects the operating system to buffer normal writes, only forcing them out to disk when the background checkpoints complete. The size of this write cache was much larger than is normally preferred on Linux kernels before 2.6.22, which includes the still popular RedHat Enterprise 5. You can get the better new defaults on older kernels like this:echo 10 > /proc/sys/vm/dirty_ratio echo 5 > /proc/sys/vm/dirty_background_ratio These settings allow 10% of RAM to be used as a write cache, preemptively stepping up the rate it's written once it reaches 5%. These numbers may still be too high on systems with many gigabytes of memory. Starting in Linux kernel 2.6.29, these values can be set even smaller using the new "dirty_background_bytes" and "dirty_bytes" settings.  They replace the percentage based values when you use them. Note that some bulk operations in PostgreSQL, particularly VACUUM, may slow significantly if you reduce Linux's write cache by too much.I/O SchedulingParticularly when running a workload with a heavy mix of read and write operations, Linux's kernel I/O scheduler can impact performance when the system gets very busy. It's hard to see a useful difference here if you just do simple performance testing, and the options already mentioned normally have a bigger impact. But on a complicated database workload, the scheduler can make a significant difference too.The default scheduler, Completely Fair Queuing (CFQ), is a good starting point but not optimal in every case. The primary alternative to consider is the deadline scheduler, which can give better response times with a read/write mix where response time latency is important.  If you have a disk array with some intelligence in it, such as a good RAID controller or external SAN storage, I/O scheduling may just add overhead without any benefit. In those cases, using the NOOP scheduler may give best performance. It does a minimal amount of work, assuming the disks or their controller will make good decisions instead.